<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloomreach Omniconnect AI Transformer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        .chat-message {
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .tab-content {
            height: calc(100vh - 200px);
        }
        pre { margin: 0 !important; }
        code { font-size: 0.875rem !important; }
        .chat-input {
            resize: vertical;
            min-height: 80px;
            max-height: 200px;
        }
        .notification {
            animation: slideInRight 0.3s ease-out;
        }
        @keyframes slideInRight {
            from { 
                opacity: 0; 
                transform: translateX(100%) translateY(-50%);
            }
            to { 
                opacity: 1; 
                transform: translateX(0) translateY(-50%);
            }
        }
        .notification-exit {
            animation: slideOutRight 0.3s ease-in forwards;
        }
        @keyframes slideOutRight {
            from { 
                opacity: 1; 
                transform: translateX(0) translateY(-50%);
            }
            to { 
                opacity: 0; 
                transform: translateX(100%) translateY(-50%);
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Updated system prompt based on actual Bloomreach Omniconnect specification
        const SYSTEM_PROMPT = `You are an expert at creating Bloomreach Omniconnect transformation functions. You help users transform webhook payloads into Bloomreach Engagement events.

CRITICAL REQUIREMENTS:
1. Always return ONLY a JavaScript function named 'handler' that takes a 'payload' parameter
2. The function must return an array of event objects (even if just one event)
3. Use const and let instead of var for variables
4. No 3rd party libraries or console.log() allowed
5. Must include utility functions if needed (like timestamp helpers)

EVENT TYPES AND STRUCTURE:

**CUSTOMER UPDATE EVENT:**
{
    "name": "customers",
    "command_id": "unique-string-id", 
    "data": {
        "customer_ids": {
            "registered": "customer@email.com",
            "email_id": "customer@email.com"
            // At least one customer ID required
        },
        "properties": {
            "first_name": "John",
            "last_name": "Doe"
            // Customer properties to update
        },
        "update_timestamp": 1614941503 // Unix timestamp in seconds (REQUIRED)
    }
}

**CUSTOMER EVENT:**
{
    "name": "customers/events",
    "command_id": "unique-string-id",
    "data": {
        "customer_ids": {
            "registered": "customer@email.com",
            "email_id": "customer@email.com"
            // At least one customer ID required
        },
        "event_type": "purchase", // REQUIRED: event name
        "timestamp": 1614941503, // Unix timestamp in seconds (REQUIRED)
        "properties": {
            "total_price": 1234.50,
            "product_name": "Widget"
            // Event-specific properties
        }
    }
}

PREDEFINED CONSTANTS (available in Bloomreach):
- INTEGRATION_ID: Current integration identifier
- COMPANY_ID: Project ID in Engagement Platform  
- INTEGRATION_NAME: Name of the webhook handler

REQUIRED UTILITY FUNCTIONS TO INCLUDE:
\`\`\`javascript
function currentTimestampInSeconds() {
    return Math.round(Date.now() / 1000);
}

function parseDateToTimestampInSeconds(dateStr) {
    const date = new Date(dateStr);
    return Math.round(date.getTime() / 1000);
}
\`\`\`

EXAMPLE STRUCTURE:
\`\`\`javascript
function handler(payload) {
    const event_list = [];
    
    // Extract customer IDs (at least one required)
    const customerIDs = {
        "registered": payload.email || payload.customer_email,
        "email_id": payload.email || payload.customer_email
    };
    
    // Customer Update Event (optional)
    const customerUpdate = {
        name: "customers",
        command_id: String(payload.id + "-update"),
        data: {
            customer_ids: customerIDs,
            properties: {
                first_name: payload.first_name,
                last_name: payload.last_name
            },
            update_timestamp: currentTimestampInSeconds()
        }
    };
    event_list.push(customerUpdate);
    
    // Customer Event (for tracking behavior)
    const customerEvent = {
        name: "customers/events", 
        command_id: String(payload.id + "-event"),
        data: {
            customer_ids: customerIDs,
            event_type: payload.event_type || "custom_event",
            timestamp: currentTimestampInSeconds(),
            properties: {
                // Map relevant payload fields to event properties
            }
        }
    };
    event_list.push(customerEvent);
    
    return event_list;
}
\`\`\`

FOR CSV DATA:
- payload will be an array of row objects
- Process each row with payload.forEach() or payload.map()
- Generate events for each row or aggregate across rows
- Always ensure customer_ids are properly extracted from each row

When users describe transformations, generate the complete handler function with:
- Proper customer ID extraction
- Appropriate event types based on the data
- Correct timestamp handling
- Field mappings as requested
- Conditional logic for different scenarios
- Multiple events if needed (updates + behavioral events)
- All required utility functions included`;

        // Toast Notification Component
        function ToastNotification({ message, type = 'success', onClose }) {
            const [isExiting, setIsExiting] = useState(false);

            useEffect(() => {
                const timer = setTimeout(() => {
                    setIsExiting(true);
                    setTimeout(onClose, 300); // Match animation duration
                }, 2000);

                return () => clearTimeout(timer);
            }, [onClose]);

            const bgColor = type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500';
            const icon = type === 'success' ? (
                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
            ) : type === 'error' ? (
                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
            ) : (
                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            );

            return (
                <div className={`fixed top-4 right-4 z-50 ${bgColor} text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-3 min-w-64 notification ${isExiting ? 'notification-exit' : ''}`}>
                    {icon}
                    <span className="text-sm font-medium">{message}</span>
                    <button
                        onClick={() => {
                            setIsExiting(true);
                            setTimeout(onClose, 300);
                        }}
                        className="ml-auto text-white hover:text-gray-200 transition-colors"
                    >
                        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            );
        }

        function App() {
            const [inputJson, setInputJson] = useState('');
            const [inputType, setInputType] = useState('json'); // 'json' or 'csv'
            const [csvHeaders, setCsvHeaders] = useState([]);
            const [messages, setMessages] = useState([]);
            const [inputMessage, setInputMessage] = useState('');
            const [generatedCode, setGeneratedCode] = useState('// Your Bloomreach Omniconnect handler function will appear here');
            const [preview, setPreview] = useState('');
            const [previewError, setPreviewError] = useState('');
            const [activeTab, setActiveTab] = useState('code');
            const [apiKey, setApiKey] = useState('');
            const [loading, setLoading] = useState(false);
            const [notifications, setNotifications] = useState([]);
            const fileInputRef = useRef(null);
            const chatEndRef = useRef(null);
            const textareaRef = useRef(null);

            useEffect(() => {
                // Check for API key in localStorage
                const savedKey = localStorage.getItem('openai_api_key');
                if (savedKey) setApiKey(savedKey);

                // Set example JSON that matches common webhook payload patterns
                const exampleJson = {
                    "event_id": "EVT-12345",
                    "customer_data": {
                        "email": "john.doe@example.com",
                        "first_name": "John",
                        "last_name": "Doe",
                        "created_at": "2024-01-15T10:30:00Z",
                        "event_type": "registration"
                    },
                    "customer_event_data": {
                        "event_type": "form_submission",
                        "title": "Newsletter Signup",
                        "form_id": "FORM-001",
                        "submitted_at": "2024-01-15T10:30:00Z",
                        "tags": ["newsletter", "marketing"]
                    }
                };
                setInputJson(JSON.stringify(exampleJson, null, 2));
            }, []);

            useEffect(() => {
                chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages]);

            // Auto-resize textarea based on content
            useEffect(() => {
                if (textareaRef.current) {
                    textareaRef.current.style.height = 'auto';
                    textareaRef.current.style.height = Math.min(textareaRef.current.scrollHeight, 200) + 'px';
                }
            }, [inputMessage]);

            // Notification system
            const showNotification = (message, type = 'success') => {
                const id = Date.now();
                const notification = { id, message, type };
                setNotifications(prev => [...prev, notification]);
            };

            const removeNotification = (id) => {
                setNotifications(prev => prev.filter(notif => notif.id !== id));
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        
                        if (file.name.endsWith('.csv')) {
                            // Parse CSV
                            Papa.parse(content, {
                                header: true,
                                complete: (results) => {
                                    setInputType('csv');
                                    setCsvHeaders(results.meta.fields || []);
                                    // Store both raw CSV and sample JSON
                                    setInputJson(content);
                                    showNotification(`CSV file loaded with ${results.data.length} rows`);
                                    // Show a sample of parsed data in the chat
                                    const sample = results.data.slice(0, 3);
                                    console.log('CSV parsed, sample:', sample);
                                },
                                error: (error) => {
                                    showNotification('Error parsing CSV: ' + error.message, 'error');
                                }
                            });
                        } else {
                            // Parse JSON
                            try {
                                const json = JSON.parse(content);
                                setInputType('json');
                                setInputJson(JSON.stringify(json, null, 2));
                                showNotification('JSON file loaded successfully');
                            } catch (err) {
                                showNotification('Invalid JSON file', 'error');
                            }
                        }
                    };
                    reader.readAsText(file);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file && (file.type === 'application/json' || file.name.endsWith('.csv'))) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const content = event.target.result;
                        
                        if (file.name.endsWith('.csv')) {
                            // Parse CSV
                            Papa.parse(content, {
                                header: true,
                                complete: (results) => {
                                    setInputType('csv');
                                    setCsvHeaders(results.meta.fields || []);
                                    setInputJson(content);
                                    showNotification(`CSV file loaded with ${results.data.length} rows`);
                                },
                                error: (error) => {
                                    showNotification('Error parsing CSV: ' + error.message, 'error');
                                }
                            });
                        } else {
                            // Parse JSON
                            try {
                                const json = JSON.parse(content);
                                setInputType('json');
                                setInputJson(JSON.stringify(json, null, 2));
                                showNotification('JSON file loaded successfully');
                            } catch (err) {
                                showNotification('Invalid JSON file', 'error');
                            }
                        }
                    };
                    reader.readAsText(file);
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
            };

            const sendMessage = async () => {
                if (!inputMessage.trim() || !apiKey) {
                    if (!apiKey) showNotification('Please enter your OpenAI API key', 'error');
                    return;
                }

                const userMessage = inputMessage;
                setInputMessage('');
                setMessages(prev => [...prev, { role: 'user', content: userMessage }]);
                setLoading(true);

                try {
                    let contextMessage = '';
                    if (inputType === 'csv') {
                        contextMessage = `Here is a CSV file with columns: ${csvHeaders.join(', ')}\n\nThe payload will be an array where each element represents a row of the CSV.\n\nUser request: ${userMessage}`;
                    } else {
                        contextMessage = `Here is the input JSON payload:\n${inputJson}\n\nUser request: ${userMessage}`;
                    }

                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o',
                            messages: [
                                { role: 'system', content: SYSTEM_PROMPT },
                                { role: 'user', content: contextMessage }
                            ],
                            temperature: 0.3
                        })
                    });

                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error.message);
                    }

                    const assistantResponse = data.choices[0].message.content;
                    setMessages(prev => [...prev, { role: 'assistant', content: assistantResponse }]);

                    // Extract the code from the response with better parsing
                    let fullCode = '';
                    
                    // First try to extract everything between ```javascript and ``` or ```
                    const codeBlockMatch = assistantResponse.match(/```(?:javascript)?\s*([\s\S]*?)```/);
                    if (codeBlockMatch) {
                        fullCode = codeBlockMatch[1].trim();
                    } else {
                        // Fallback: extract individual functions
                        const functionMatches = assistantResponse.match(/function\s+\w+\s*\([^)]*\)\s*{[\s\S]*?^}/gm);
                        if (functionMatches) {
                            fullCode = functionMatches.join('\n\n');
                        }
                    }
                    
                    if (fullCode) {
                        setGeneratedCode(fullCode);
                        setTimeout(() => Prism.highlightAll(), 100);
                        showNotification('Handler function generated successfully!');
                        
                        // Generate preview with better error handling
                        try {
                            // Clean up the code and ensure all functions are properly defined
                            let cleanCode = fullCode;
                            
                            // Ensure utility functions are present if handler exists but they don't
                            if (cleanCode.includes('function handler') && !cleanCode.includes('function currentTimestampInSeconds')) {
                                const utilityFunctions = `
function currentTimestampInSeconds() {
    return Math.round(Date.now() / 1000);
}

function parseDateToTimestampInSeconds(dateStr) {
    const date = new Date(dateStr);
    return Math.round(date.getTime() / 1000);
}
`;
                                cleanCode = utilityFunctions + '\n\n' + cleanCode;
                            }
                            
                            // Create execution environment
                            const executionCode = `
(function() {
    // Bloomreach constants
    const INTEGRATION_ID = "test-integration";
    const COMPANY_ID = "test-company"; 
    const INTEGRATION_NAME = "Test Integration";
    
    ${cleanCode}
    
    // Ensure handler function exists
    if (typeof handler !== 'function') {
        throw new Error('No handler function found in generated code');
    }
    
    return handler;
})()`;
                            
                            const handlerFunc = eval(executionCode);
                            let inputData;
                            
                            if (inputType === 'csv') {
                                // Parse CSV for preview
                                const parsed = Papa.parse(inputJson, { 
                                    header: true,
                                    dynamicTyping: true,
                                    skipEmptyLines: true 
                                });
                                inputData = parsed.data.filter(row => Object.keys(row).some(key => row[key] !== null && row[key] !== ''));
                            } else {
                                inputData = JSON.parse(inputJson);
                            }
                            
                            const output = handlerFunc(inputData);
                            
                            // Validate output structure
                            if (!Array.isArray(output)) {
                                throw new Error('Handler must return an array of events');
                            }
                            
                            // Check if events have required fields
                            output.forEach((event, index) => {
                                if (!event.name || !event.data) {
                                    throw new Error(`Event ${index} missing required 'name' or 'data' field`);
                                }
                                if (event.name === 'customers' && !event.data.update_timestamp) {
                                    console.warn(`Customer update event ${index} missing update_timestamp`);
                                }
                                if (event.name === 'customers/events' && (!event.data.event_type || !event.data.timestamp)) {
                                    console.warn(`Customer event ${index} missing event_type or timestamp`);
                                }
                            });
                            
                            setPreview(JSON.stringify(output, null, 2));
                            setPreviewError('');
                        } catch (err) {
                            console.error('Preview generation error:', err);
                            setPreviewError(err.message);
                            setPreview(`// Preview Error: ${err.message}\n// \n// Debug Info:\n// - Input type: ${inputType}\n// - Functions found: ${cleanCode.includes('function handler') ? 'handler' : 'missing'}\n// - Code length: ${cleanCode.length} chars\n//\n// Please check:\n// 1. All functions are properly closed with }\n// 2. handler function exists and returns an array\n// 3. No syntax errors in the generated code\n//\n// Raw extracted code:\n/*\n${cleanCode.substring(0, 500)}${cleanCode.length > 500 ? '...' : ''}\n*/`);
                        }
                    } else {
                        setPreview('// No code found in response. Please try again or refine your request.');
                        showNotification('No handler function found in response', 'error');
                    }
                } catch (error) {
                    setMessages(prev => [...prev, { role: 'assistant', content: `Error: ${error.message}` }]);
                    showNotification('Error: ' + error.message, 'error');
                } finally {
                    setLoading(false);
                }
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            };

            const testPreview = () => {
                if (!generatedCode || generatedCode === '// Your Bloomreach Omniconnect handler function will appear here') {
                    showNotification('No generated code to test. Please generate a handler function first.', 'error');
                    return;
                }
                
                try {
                    // Test the current generated code
                    let cleanCode = generatedCode;
                    
                    // Ensure utility functions are present
                    if (cleanCode.includes('function handler') && !cleanCode.includes('function currentTimestampInSeconds')) {
                        const utilityFunctions = `
function currentTimestampInSeconds() {
    return Math.round(Date.now() / 1000);
}

function parseDateToTimestampInSeconds(dateStr) {
    const date = new Date(dateStr);
    return Math.round(date.getTime() / 1000);
}
`;
                        cleanCode = utilityFunctions + '\n\n' + cleanCode;
                    }
                    
                    const executionCode = `
(function() {
    const INTEGRATION_ID = "test-integration";
    const COMPANY_ID = "test-company"; 
    const INTEGRATION_NAME = "Test Integration";
    
    ${cleanCode}
    
    if (typeof handler !== 'function') {
        throw new Error('No handler function found in generated code');
    }
    
    return handler;
})()`;
                    
                    const handlerFunc = eval(executionCode);
                    let inputData;
                    
                    if (inputType === 'csv') {
                        const parsed = Papa.parse(inputJson, { 
                            header: true,
                            dynamicTyping: true,
                            skipEmptyLines: true 
                        });
                        inputData = parsed.data.filter(row => Object.keys(row).some(key => row[key] !== null && row[key] !== ''));
                    } else {
                        inputData = JSON.parse(inputJson);
                    }
                    
                    const output = handlerFunc(inputData);
                    
                    if (!Array.isArray(output)) {
                        throw new Error('Handler must return an array of events');
                    }
                    
                    setPreview(JSON.stringify(output, null, 2));
                    setPreviewError('');
                    setActiveTab('preview');
                    showNotification('Code tested successfully!');
                    
                } catch (err) {
                    setPreviewError(err.message);
                    setPreview(`// Test Error: ${err.message}\n// \n// This usually means:\n// 1. Syntax error in generated code\n// 2. Missing handler function\n// 3. Input data format issue\n//\n// Check the Handler Function tab for issues.`);
                    setActiveTab('preview');
                    showNotification('Test failed: ' + err.message, 'error');
                }
            };

            const copyCode = async () => {
                try {
                    await navigator.clipboard.writeText(generatedCode);
                    showNotification('Code copied to clipboard!');
                } catch (err) {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = generatedCode;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showNotification('Code copied to clipboard!');
                }
            };

            const saveApiKey = () => {
                localStorage.setItem('openai_api_key', apiKey);
                showNotification('API key saved!');
            };

            return (
                <div className="min-h-screen bg-gray-50 flex flex-col">
                    {/* Notifications */}
                    {notifications.map(notification => (
                        <ToastNotification
                            key={notification.id}
                            message={notification.message}
                            type={notification.type}
                            onClose={() => removeNotification(notification.id)}
                        />
                    ))}

                    {/* Header */}
                    <header className="bg-white shadow-sm border-b">
                        <div className="max-w-7xl mx-auto px-4 py-4 sm:px-6 lg:px-8">
                            <div className="flex items-center justify-between">
                                <div>
                                    <h1 className="text-2xl font-bold text-gray-900">Bloomreach Omniconnect AI Transformer</h1>
                                    <p className="text-sm text-gray-600 mt-1">Generate webhook transformation functions for Bloomreach Engagement</p>
                                </div>
                                <div className="flex items-center gap-2">
                                    <input
                                        type="password"
                                        placeholder="OpenAI API Key"
                                        value={apiKey}
                                        onChange={(e) => setApiKey(e.target.value)}
                                        className="px-3 py-1 border rounded-md text-sm w-64"
                                    />
                                    <button
                                        onClick={saveApiKey}
                                        className="text-sm bg-gray-100 text-gray-700 px-3 py-1 rounded-md hover:bg-gray-200"
                                    >
                                        Save
                                    </button>
                                </div>
                            </div>
                        </div>
                    </header>

                    {/* Main Content */}
                    <main className="flex-1 max-w-7xl w-full mx-auto px-4 py-6 sm:px-6 lg:px-8">
                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 h-full">
                            {/* Input Panel */}
                            <div className="bg-white rounded-lg shadow-sm border p-4">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-lg font-semibold">Webhook Payload Sample</h2>
                                    {inputType === 'csv' && (
                                        <span className="text-sm bg-green-100 text-green-700 px-2 py-1 rounded">
                                            CSV
                                        </span>
                                    )}
                                </div>
                                <div
                                    onDrop={handleDrop}
                                    onDragOver={handleDragOver}
                                    className="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center mb-4 hover:border-gray-400 transition-colors"
                                >
                                    <svg className="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                                    </svg>
                                    <p className="mt-2 text-sm text-gray-600">Drag & drop JSON or CSV file</p>
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        accept=".json,.csv"
                                        onChange={handleFileUpload}
                                        className="hidden"
                                    />
                                    <button
                                        onClick={() => fileInputRef.current.click()}
                                        className="mt-2 text-sm text-blue-600 hover:text-blue-700"
                                    >
                                        Choose file
                                    </button>
                                </div>
                                {inputType === 'csv' && csvHeaders.length > 0 && (
                                    <div className="mb-3 p-3 bg-gray-50 rounded">
                                        <p className="text-sm font-medium text-gray-700 mb-1">CSV Columns:</p>
                                        <div className="flex flex-wrap gap-1">
                                            {csvHeaders.map((header, idx) => (
                                                <span key={idx} className="text-xs bg-white px-2 py-1 rounded border">
                                                    {header}
                                                </span>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                <textarea
                                    value={inputJson}
                                    onChange={(e) => setInputJson(e.target.value)}
                                    className="w-full h-80 p-3 border rounded-lg font-mono text-sm resize-none"
                                    placeholder={inputType === 'csv' ? "CSV content..." : "Or paste webhook JSON payload here..."}
                                />
                            </div>

                            {/* Chat Panel */}
                            <div className="bg-white rounded-lg shadow-sm border p-4 flex flex-col">
                                <h2 className="text-lg font-semibold mb-4">Describe Your Transformation</h2>
                                
                                {/* Initial helper message */}
                                {messages.length === 0 && (
                                    <div className="flex-1 flex items-center justify-center">
                                        <div className="text-center text-gray-500 text-sm max-w-xs">
                                            <p className="mb-4">Tell me how to transform this payload into Bloomreach events:</p>
                                            <div className="space-y-2 text-left bg-gray-50 p-3 rounded">
                                                <p className="text-xs">• "Create customer update and purchase event"</p>
                                                <p className="text-xs">• "Map email to customer ID, create form submission event"</p>
                                                <p className="text-xs">• "For each CSV row, update customer and track signup"</p>
                                                <p className="text-xs">• "Extract order items into separate events"</p>
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {/* Chat messages */}
                                <div className="flex-1 overflow-y-auto mb-4 space-y-4">
                                    {messages.map((msg, idx) => (
                                        <div key={idx} className={`chat-message ${msg.role === 'user' ? 'text-right' : ''}`}>
                                            <div className={`inline-block p-3 rounded-lg max-w-[80%] ${
                                                msg.role === 'user' 
                                                    ? 'bg-blue-600 text-white' 
                                                    : 'bg-gray-100 text-gray-800'
                                            }`}>
                                                <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                                            </div>
                                        </div>
                                    ))}
                                    {loading && (
                                        <div className="chat-message">
                                            <div className="inline-block p-3 rounded-lg bg-gray-100">
                                                <div className="flex space-x-2">
                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '0.1s'}}></div>
                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '0.2s'}}></div>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    <div ref={chatEndRef} />
                                </div>

                                {/* Enhanced Input area */}
                                <div className="border-t pt-4">
                                    <div className="flex flex-col gap-2">
                                        <textarea
                                            ref={textareaRef}
                                            value={inputMessage}
                                            onChange={(e) => setInputMessage(e.target.value)}
                                            onKeyPress={handleKeyPress}
                                            placeholder="Describe your mapping requirements... (Shift+Enter for new line, Enter to send)"
                                            className="w-full px-4 py-3 border rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 chat-input"
                                            disabled={loading}
                                            rows="3"
                                        />
                                        <div className="flex justify-between items-center">
                                            <span className="text-xs text-gray-500">
                                                Shift+Enter for new line • Enter to send
                                            </span>
                                            <button
                                                onClick={sendMessage}
                                                disabled={loading || !inputMessage.trim()}
                                                className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center gap-2"
                                            >
                                                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                                </svg>
                                                Generate
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            {/* Output Panel */}
                            <div className="bg-white rounded-lg shadow-sm border p-4 flex flex-col">
                                <div className="flex gap-2 mb-4">
                                    <button
                                        onClick={() => setActiveTab('code')}
                                        className={`px-4 py-2 text-sm font-medium rounded-lg ${
                                            activeTab === 'code' 
                                                ? 'bg-blue-100 text-blue-700' 
                                                : 'text-gray-600 hover:bg-gray-100'
                                        }`}
                                    >
                                        Handler Function
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('preview')}
                                        className={`px-4 py-2 text-sm font-medium rounded-lg ${
                                            activeTab === 'preview' 
                                                ? 'bg-blue-100 text-blue-700' 
                                                : 'text-gray-600 hover:bg-gray-100'
                                        }`}
                                    >
                                        Output Preview
                                    </button>
                                    <div className="flex-1"></div>
                                    <button
                                        onClick={copyCode}
                                        className="text-sm bg-gray-100 text-gray-700 px-3 py-1 rounded hover:bg-gray-200 flex items-center gap-1"
                                    >
                                        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                        </svg>
                                        Copy Code
                                    </button>
                                </div>

                                <div className="flex-1 overflow-hidden">
                                    {activeTab === 'code' ? (
                                        <div className="h-full overflow-auto">
                                            <pre className="language-javascript h-full"><code>{generatedCode}</code></pre>
                                        </div>
                                    ) : (
                                        <div className="h-full overflow-auto">
                                            <pre className="bg-gray-50 p-4 rounded text-sm">{preview || '// Event output will appear here after generating the handler function'}</pre>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </main>

                    {/* Footer */}
                    <footer className="bg-white border-t">
                        <div className="max-w-7xl mx-auto px-4 py-3 sm:px-6 lg:px-8">
                            <p className="text-xs text-gray-500 text-center">
                                Generated code follows Bloomreach Omniconnect specifications. Copy and paste into your Bloomreach webhook handler.
                            </p>
                        </div>
                    </footer>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>